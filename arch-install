#!/usr/bin/env bash

##########################################
# UnOfficial Installer - ArchLinux[Neon] #
# AUTHOR : z3r0.c01n (at) protonmail.com #
##########################################

# TODO : spotify, lock-color, speedometer, tor-browser, xmrig, mycrypto, inxi

# arch-installer version
VERSION='21.1.12'

# path to arch-installer
BI_PATH='/usr/share/arch-installer'

# true / false
TRUE=0
FALSE=1

# return codes
SUCCESS=0
FAILURE=1

#install delay
DELAY_1="1"
DELAY_10="10"

# verbose mode - default: quiet
VERBOSE='/dev/null'

# colors
WHITE="$(tput setaf 7)"
BLUEB="$(tput bold ; tput setaf 4)"
MAGENTA="$(tput bold ; tput setaf 5)"
CYANB="$(tput bold ; tput setaf 6)"
RED="$(tput setaf 1)"
YELLOW="$(tput setaf 3)"
NC="$(tput sgr0)"

# installation mode (gui/net)
INSTALL_MODE='gui'

# chosen locale
LOCALE=''

# set locale
SET_LOCALE='1'

# list locales
LIST_LOCALE='2'

# chosen keymap
KEYMAP=''

# set keymap
SET_KEYMAP='1'

# list keymaps
LIST_KEYMAP='2'

# network interfaces
NET_IFS=''

# chosen network interface
NET_IF=''

# network configuration mode
NET_CONF_MODE=''

# network configuration modes
NET_CONF_AUTO='1'
NET_CONF_WLAN='2'
NET_CONF_MANUAL='3'
NET_CONF_SKIP='4'

# hostname
HOST_NAME=''

# host ipv4 address
HOST_IPV4=''

# gateway ipv4 address
GATEWAY=''

# subnet mask
SUBNETMASK=''

# broadcast address
BROADCAST=''

# nameserver address
NAMESERVER=''

# LUKS flag
LUKS=''

# avalable hard drive
HD_DEVS=''

# chosen hard drive device
HD_DEV=''

# Partitions
PARTITIONS=''

# partition label: gpt or dos
PART_LABEL=''

# boot partition
BOOT_PART=''

# root partition
ROOT_PART=''

# crypted root
CRYPT_ROOT='r00t'

# swap partition
SWAP_PART=''

# boot fs type - default: ext4
BOOT_FS_TYPE=''

# root fs type - default: ext4
ROOT_FS_TYPE=''

# chroot directory / arch linux installation
CHROOT='/mnt'

# normal system user
NORMAL_USER=''

# default ArchLinux repository URL
ARCH_REPO_URL="http://mirror.archlinux.guru/archlinux/\$repo/os/\$arch"
ARCH_REPO_URL="$ARCH_REPO_URL http://mirror.archlinux.cool/archlinux/\$repo/os/\$arch"

# X (display + window managers ) setup - default: false
X_SETUP=$FALSE

# VMware setup - default: false
VMWARE_SETUP=$FALSE

# wlan ssid
WLAN_SSID=''

# wlan passphrase
WLAN_PASSPHRASE=''

# check boot mode
BOOT_MODE=''


# Exit on CTRL + c
ctrl_c() {
  err "Keyboard Interrupt detected, leaving..."
  exit $FAILURE
}

trap ctrl_c 2


# check exit status
check()
{
  es=$1
  func="$2"
  info="$3"

  if [ "$es" -ne 0 ]
  then
    echo
    warn "Something went wrong with $func. $info."
    sleep "$DELAY_1"
  fi
}


# print formatted output
wprintf()
{
  fmt="${1}"

  shift
  printf "%s$fmt%s" "$WHITE" "$@" "$NC"

  return $SUCCESS
}


# print warning
warn()
{
  printf "%s[!] WARNING: %s%s\n" "$YELLOW" "$@" "$NC"

  return $SUCCESS
}


# print error and return failure
err()
{
  printf "%s[-] ERROR: %s%s\n" "$RED" "$@" "$NC"

  return $FAILURE
}


# show top banner
banner()
{
  columns="$(tput cols)"
  str="[ Arch Installer v$VERSION ]"

  printf "${BLUEB}%*s${NC}\n" "${COLUMNS:-$(tput cols)}" | tr ' ' '*'

  echo "$str" |
  while IFS= read -r line
  do
    printf "%s%*s\n%s" "$CYANB" $(( (${#line} + columns) / 2)) "$line" "$NC"
  done

  printf "${BLUEB}%*s${NC}\n\n\n" "${COLUMNS:-$(tput cols)}" | tr ' ' '*'

  return $SUCCESS
}


# check boot mode
check_boot_mode()
{
  if [ "$(efivar --list 2> /dev/null)" ]
  then
     BOOT_MODE="uefi"
  fi

  return $SUCCESS
}


# sleep and clear
sleep_clear()
{
  sleep "$1"
  clear

  return $SUCCESS
}


# confirm user inputted yYnN
confirm()
{
  header="$1"
  ask="$2"

  while true
  do
    title "$header"
    wprintf "$ask"
    read -r input
    case $input in
      y|Y|yes|YES|Yes) return $TRUE ;;
      n|N|no|NO|No) return $FALSE ;;
      *) clear ; continue ;;
    esac
  done

  return $SUCCESS
}


# print menu title
title()
{
  banner
  printf "${MAGENTA}# %s${NC}\n\n\n" "${@}"

  return "${SUCCESS}"
}


# check for environment issues
check_env()
{
  if [ -f '/var/lib/pacman/db.lck' ]
  then
    err 'pacman locked - Please remove /var/lib/pacman/db.lck'
  fi
}


# check user id
check_uid()
{
  if [ "$(id -u)" != '0' ]
  then
    err 'You must be root to run the Arch installer!'
  fi

  return $SUCCESS
}


# ask for output mode
ask_output_mode()
{
  title 'Environment > Output Mode'
  wprintf '[+] Available output modes:'
  printf "\n
  1. Quiet (default)
  2. Verbose (output of system commands: mkfs, pacman, etc.)\n\n"
  wprintf "[?] Make a choice: "
  read -r output_opt
  if [ "$output_opt" = 2 ]
  then
    VERBOSE='/dev/stdout'
  fi

  return $SUCCESS
}

# ask for install mode
ask_install_mode()
{
  title 'Environment > Install Mode'
  wprintf '[+] Available install modes:'
  printf "\n
  1. GUI (slim/i3) (default)
  2. NET (minimal) \n\n"
  wprintf "[?] Make a choice: "
  read -r install_mode
  if [ "$install_mode" = 2 ]
  then
    INSTALL_MODE='net'
  fi

  return $SUCCESS
}

# ask for locale to use
ask_locale()
{
  while [ "$locale_opt" != "$SET_LOCALE" ] && [ "$locale_opt" != "$LIST_LOCALE" ]
  do
    title 'Environment > Locale Setup'
    wprintf '[+] Available locale options:'
    printf "\n
  1. Set a locale
  2. List available locales\n\n"
    wprintf "[?] Make a choice: "
    read -r locale_opt
    if [ "$locale_opt" = "$SET_LOCALE" ]
    then
      break
    elif [ "$locale_opt" = "$LIST_LOCALE" ]
    then
      less /etc/locale.gen
      echo
    else
      clear
      continue
    fi
    clear
  done

  clear

  return $SUCCESS
}


# set locale to use
set_locale()
{
  title 'Environment > Locale Setup'
  wprintf '[?] Set locale [en_US.UTF-8]: '
  read -r LOCALE

  # default locale
  if [ -z "$LOCALE" ]
  then
    echo
    warn 'Setting default locale: en_US.UTF-8'
    sleep "$DELAY_1"
    LOCALE='en_US.UTF-8'
  fi
  localectl set-locale "LANG=$LOCALE"
  check $? 'setting locale'

  return $SUCCESS
}


# ask for keymap to use
ask_keymap()
{
  while [ "$keymap_opt" != "$SET_KEYMAP" ] && [ "$keymap_opt" != "$LIST_KEYMAP" ]
  do
    title 'Environment > Keymap Setup'
    wprintf '[+] Available keymap options:'
    printf "\n
  1. Set a keymap
  2. List available keymaps\n\n"
    wprintf '[?] Make a choice: '
    read -r keymap_opt

    if [ "$keymap_opt" = "$SET_KEYMAP" ]
    then
      break
    elif [ "$keymap_opt" = "$LIST_KEYMAP" ]
    then
      localectl list-keymaps
      echo
    else
      clear
      continue
    fi
    clear
  done

  clear

  return $SUCCESS
}


# set keymap to use
set_keymap()
{
  title 'Environment > Keymap Setup'
  wprintf '[?] Set keymap [de]: '
  read -r KEYMAP

  # default keymap
  if [ -z "$KEYMAP" ]
  then
    echo
    warn 'Setting default keymap: de'
    sleep "$DELAY_1"
    KEYMAP='de'
  fi
  localectl set-keymap --no-convert "$KEYMAP"
  loadkeys "$KEYMAP" > $VERBOSE 2>&1
  check $? 'setting keymap'

  return $SUCCESS
}


# enable multilib in pacman.conf if x86_64 present
enable_pacman_multilib()
{
  path="$1"

  if [ "$path" = 'chroot' ]
  then
    path="$CHROOT"
  else
    path=""
  fi

  title 'Pacman Setup > Multilib'

  if [ "$(uname -m)" = "x86_64" ]
  then
    wprintf '[+] Enabling multilib support'
    printf "\n\n"
    if grep -q "#\[multilib\]" "$path/etc/pacman.conf"
    then
      # it exists but commented
      sed -i '/\[multilib\]/{ s/^#//; n; s/^#//; }' "$path/etc/pacman.conf"
    elif ! grep -q "\[multilib\]" "$path/etc/pacman.conf"
    then
      # it does not exist at all
      printf "[multilib]\nInclude = /etc/pacman.d/mirrorlist\n" >> "$path/etc/pacman.conf"
    fi
  fi

  return $SUCCESS
}


# enable color mode in pacman.conf
enable_pacman_color()
{
  path="$1"

  if [ "$path" = 'chroot' ]
  then
    path="$CHROOT"
  else
    path=""
  fi

  title 'Pacman Setup > Color'

  wprintf '[+] Enabling color mode'
  printf "\n\n"

  sed -i 's/^#Color/Color/' "$path/etc/pacman.conf"

  return $SUCCESS
}


# enable misc options in pacman.conf
enable_pacman_misc()
{
  path="$1"

  if [ "$path" = 'chroot' ]
  then
    path="$CHROOT"
  else
    path=""
  fi

  title 'Pacman Setup > Misc Options'

  wprintf '[+] Enabling DisableDownloadTimeout'
  printf "\n\n"
  sed -i '37a DisableDownloadTimeout' "$path/etc/pacman.conf"

  # put here more misc options if necessary

  return $SUCCESS
}


# update pacman package database
update_pkg_database()
{
  title 'Pacman Setup > Package Database'

  wprintf '[+] Updating pacman database'
  printf "\n\n"

  pacman -Syy --noconfirm > $VERBOSE 2>&1

  return $SUCCESS
}


# update pacman.conf and database
update_pacman()
{
  enable_pacman_multilib
  sleep_clear "$DELAY_1"

  enable_pacman_color
  sleep_clear "$DELAY_1"

  enable_pacman_misc
  sleep_clear "$DELAY_1"

  update_pkg_database
  sleep_clear "$DELAY_1"

  return $SUCCESS
}


# ask user for hostname
ask_hostname()
{
  while [ -z "$HOST_NAME" ]
  do
    title 'Network Setup > Hostname'
    wprintf '[?] Set your hostname: '
    read -r HOST_NAME
  done

  return $SUCCESS
}


# get available network interfaces
get_net_ifs()
{
  NET_IFS="$(ip -o link show | awk -F': ' '{print $2}' | grep -v 'lo')"

  return $SUCCESS
}


# ask user for network interface
ask_net_if()
{
  while true
  do
    title 'Network Setup > Network Interface'
    wprintf '[+] Available network interfaces:'
    printf "\n\n"
    for i in $NET_IFS
    do
      echo "    > $i"
    done
    echo
    wprintf '[?] Please choose a network interface: '
    read -r NET_IF
    if echo "$NET_IFS" | grep "\<$NET_IF\>" > /dev/null
    then
      clear
      break
    fi
    clear
  done

  return $SUCCESS
}


# ask for networking configuration mode
ask_net_conf_mode()
{
  while [ "$NET_CONF_MODE" != "$NET_CONF_AUTO" ] && \
        [ "$NET_CONF_MODE" != "$NET_CONF_WLAN" ] && \
        [ "$NET_CONF_MODE" != "$NET_CONF_MANUAL" ] && \
        [ "$NET_CONF_MODE" != "$NET_CONF_SKIP" ]
  do
    title 'Network Setup > Network Interface'
    wprintf '[+] Network interface configuration:'
    printf "\n
  1. Auto DHCP (use this for auto connect via dhcp on selected interface)
  2. WiFi WPA Setup (use if you need to connect to a wlan before)
  3. Manual (use this if you are 1337)
  4. Skip (use this if you are already connected)\n\n"
    wprintf "[?] Please choose a mode: "
    read -r NET_CONF_MODE
    clear
  done

  return $SUCCESS
}


# ask for network addresses
ask_net_addr()
{
  while [ "$HOST_IPV4" = "" ] || \
    [ "$GATEWAY" = "" ] || [ "$SUBNETMASK" = "" ] || \
    [ "$BROADCAST" = "" ] || [ "$NAMESERVER" = "" ]
  do
    title 'Network Setup > Network Configuration (manual)'
    wprintf "[+] Configuring network interface $NET_IF via USER: "
    printf "\n
  > Host ipv4
  > Gateway ipv4
  > Subnetmask
  > Broadcast
  > Nameserver
    \n"
    wprintf '[?] Host IPv4: '
    read -r HOST_IPV4
    wprintf '[?] Gateway IPv4: '
    read -r GATEWAY
    wprintf '[?] Subnetmask: '
    read -r SUBNETMASK
    wprintf '[?] Broadcast: '
    read -r BROADCAST
    wprintf '[?] Nameserver: '
    read -r NAMESERVER
    clear
  done

  return $SUCCESS
}


# manual network interface configuration
net_conf_manual()
{
  title 'Network Setup > Network Configuration (manual)'
  wprintf "[+] Configuring network interface '$NET_IF' manually: "
  printf "\n\n"

  ip addr flush dev "$NET_IF"
  ip link set "$NET_IF" up
  ip addr add "$HOST_IPV4/$SUBNETMASK" broadcast "$BROADCAST" dev "$NET_IF"
  ip route add default via "$GATEWAY"
  echo "nameserver $NAMESERVER" > /etc/resolv.conf

  return $SUCCESS
}


# auto (dhcp) network interface configuration
net_conf_auto()
{
  opts='-h noleak -i noleak -v ,noleak -I noleak -t 10'

  title 'Network Setup > Network Configuration (auto)'
  wprintf "[+] Configuring network interface '$NET_IF' via DHCP: "
  printf "\n\n"

  dhcpcd "$opts" -i "$NET_IF" > $VERBOSE 2>&1

  return $SUCCESS
}


# ask for wlan data (ssid, wpa passphrase, etc.)
ask_wlan_data()
{
  while [ "$WLAN_SSID" = "" ] || [ "$WLAN_PASSPHRASE" = "" ]
  do
    title 'Network Setup > Network Configuration (WiFi)'
    wprintf "[+] Configuring network interface $NET_IF via W-LAN + DHCP: "
    printf "\n
  > W-LAN SSID
  > WPA Passphrase (will not echo)
    \n"
    wprintf "[?] W-LAN SSID: "
    read -r WLAN_SSID
    wprintf "[?] WPA Passphrase: "
    read -rs WLAN_PASSPHRASE
    clear
  done

  return $SUCCESS
}


# wifi and auto dhcp network interface configuration
net_conf_wlan()
{
  wpasup="$(mktemp)"
  dhcp_opts='-h noleak -i noleak -v ,noleak -I noleak -t 10'

  title 'Network Setup > Network Configuration (WiFi)'
  wprintf "[+] Configuring network interface $NET_IF via W-LAN + DHCP: "
  printf "\n\n"

  wpa_passphrase "$WLAN_SSID" "$WLAN_PASSPHRASE" > "$wpasup"
  wpa_supplicant -B -c "$wpasup" -i "$NET_IF" > $VERBOSE 2>&1

  warn 'We need to wait a bit for wpa_supplicant and dhcpcd'

  sleep "$DELAY_1"

  dhcpcd "$dhcp_opts" -i "$NET_IF" > $VERBOSE 2>&1

  sleep "$DELAY_1"

  return $SUCCESS
}


# check for internet connection
check_inet_conn()
{
  title 'Network Setup > Connection Check'
  wprintf '[+] Checking for Internet connection ... '

  if ! curl -s http://www.yahoo.com/ > $VERBOSE
  then
    err 'No Internet connection! Check your network (settings).'
    exit $FAILURE
  fi

sleep "$DELAY_1"

}


# ask user for luks encrypted partition
ask_luks()
{
  while [ "$LUKS" = '' ]
  do
    if confirm 'Hard Drive Setup > Crypto' '[?] Full encrypted root [y/n]: '
    then
      LUKS=$TRUE
    else
      LUKS=$FALSE
      echo
      warn 'The root partition will NOT be encrypted'
    fi
    sleep_clear "$DELAY_1"
  done
  
  return $SUCCESS
}


# get available hard disks
get_hd_devs()
{
  HD_DEVS="$(lsblk | grep disk | awk '{print $1}')"

  return $SUCCESS
}


# ask user for device to format and setup
ask_hd_dev()
{
  while true
  do
    title 'Hard Drive Setup'

    wprintf '[+] Available hard drives for installation:'
    printf "\n\n"

    for i in $HD_DEVS
    do
      echo "    > ${i}"
    done
    echo
    wprintf '[?] Please choose a device: '
    read -r HD_DEV
    if echo "$HD_DEVS" | grep "\<$HD_DEV\>" > /dev/null
    then
      HD_DEV="/dev/$HD_DEV"
      clear
      break
    fi
    clear
  done

  return $SUCCESS
}


# get available partitions on hard drive
get_partitions()
{
  PARTITIONS=$(fdisk -l "${HD_DEV}" -o device,size,type | grep "${HD_DEV}[[:alnum:]]" |awk '{print $1;}')

  return $SUCCESS
}


# ask user to create partitions using cfdisk
ask_cfdisk()
{
  if confirm 'Hard Drive Setup > Partitions' '[?] Create partitions with cfdisk (root and boot, optional swap) [y/n]: '
  then
    clear
    zero_part
  else
    echo
    warn 'No partitions chosed? Make sure you have them already configured.'
    get_partitions
  fi

  return $SUCCESS
}


# zero out partition if needed/chosen
zero_part()
{
  local zeroed_part=0;
  if confirm 'Hard Drive Setup' '[?] Start with an in-memory zeroed partition table [y/n]: '
  zeroed_part=1;
  then
    cfdisk -z "$HD_DEV"
    sync
  else
    cfdisk "$HD_DEV"
    sync
  fi
  get_partitions
  if [ ${#PARTITIONS[@]} -eq 0 ] && [ $zeroed_part -eq 1 ] ; then
    err 'You have not created partitions on your disk, make sure to write your changes before quiting cfdisk. Trying again...'
    zero_part
  fi
  if [ "$BOOT_MODE" = 'uefi' ] && ! fdisk -l "$HD_DEV" -o type | grep -i 'EFI' ; then
    err 'You are booting in UEFI mode but not EFI partition was created, make sure you select the "EFI System" type for your EFI partition.'
    zero_part
  fi
  return $SUCCESS
}


# get partition label
get_partition_label()
{
  PART_LABEL="$(fdisk -l "$HD_DEV" | grep "Disklabel" | awk '{print $3;}')"

  return $SUCCESS
}


# get partitions
ask_partitions()
{
  while [ "$BOOT_PART" = '' ] || \
    [ "$ROOT_PART" = '' ] || \
    [ "$BOOT_FS_TYPE" = '' ] || \
    [ "$ROOT_FS_TYPE" = '' ]
  do
    title 'Hard Drive Setup > Partitions'
    wprintf '[+] Created partitions:'
    printf "\n\n"

    fdisk -l "${HD_DEV}" -o device,size,type |grep "${HD_DEV}[[:alnum:]]"

    echo

    if [ "$BOOT_MODE" = 'uefi' ]  && [ "$PART_LABEL" = 'gpt' ]
    then
      while [ -z "$BOOT_PART" ]; do
        wprintf "[?] EFI System partition (${HD_DEV}X): "
        read -r BOOT_PART
        until [[ "$PARTITIONS" =~ $BOOT_PART ]]; do
          wprintf "[?] Your partition $BOOT_PART is not in the partitions list.\n"
          wprintf "[?] EFI System partition (${HD_DEV}X): "
          read -r BOOT_PART
        done
      done
      BOOT_FS_TYPE="fat32"
    else
      while [ -z "$BOOT_PART" ]; do
        wprintf "[?] Boot partition (${HD_DEV}X): "
        read -r BOOT_PART
        until [[ "$PARTITIONS" =~ $BOOT_PART ]]; do
          wprintf "[?] Your partition $BOOT_PART is not in the partitions list.\n"
          wprintf "[?] Boot partition (${HD_DEV}X): "
          read -r BOOT_PART
        done
      done
      wprintf '[?] Choose a filesystem to use in your boot partition (ext2, ext3, ext4)? (default: ext4): '
      read -r BOOT_FS_TYPE
      if [ -z "$BOOT_FS_TYPE" ]; then
        BOOT_FS_TYPE="ext4"
      fi
    fi
    while [ -z "$ROOT_PART" ]; do
      wprintf "[?] Root partition (${HD_DEV}X): "
      read -r ROOT_PART
      until [[ "$PARTITIONS" =~ $ROOT_PART ]]; do
          wprintf "[?] Your partition $ROOT_PART is not in the partitions list.\n"
          wprintf "[?] Root partition (${HD_DEV}X): "
          read -r ROOT_PART
      done
    done
    wprintf '[?] Choose a filesystem to use in your root partition (ext2, ext3, ext4, btrfs)? (default: ext4): '
    read -r ROOT_FS_TYPE
    if [ -z "$ROOT_FS_TYPE" ]; then
      ROOT_FS_TYPE="ext4"
    fi
    wprintf "[?] Swap partition (${HD_DEV}X - empty for none): "
    read -r SWAP_PART
    if [ -n "$SWAP_PART" ]; then
        until [[ "$PARTITIONS" =~ $SWAP_PART ]]; do
          wprintf "[?] Your partition $SWAP_PART is not in the partitions list.\n"
          wprintf "[?] Swap partition (${HD_DEV}X): "
          read -r SWAP_PART
        done
    fi

    if [ "$SWAP_PART" = '' ]
    then
      SWAP_PART='none'
    fi
    clear
  done

  return $SUCCESS
}


# print partitions and ask for confirmation
print_partitions()
{
  i=""

  while true
  do
    title 'Hard Drive Setup > Partiti/ons'
    wprintf '[+] Current Partition table'
    printf "\n
  > /boot   : %s (%s)
  > /       : %s (%s)
  > swap    : %s (swap)
  \n" "$BOOT_PART" "$BOOT_FS_TYPE" \
      "$ROOT_PART" "$ROOT_FS_TYPE" \
      "$SWAP_PART"
    wprintf '[?] Partition table correct [y/n]: '
    read -r i
    if [ "$i" = 'y' ] || [ "$i" = 'Y' ]
    then
      clear
      break
    elif [ "$i" = 'n' ] || [ "$i" = 'N' ]
    then
      echo
      err 'Hard Drive Setup aborted.'
      exit $FAILURE
    else
      clear
      continue
    fi
    clear
  done

  return $SUCCESS
}


# ask user and get confirmation for formatting
ask_formatting()
{
  if confirm 'Hard Drive Setup > Partition Formatting' '[?] Formatting partitions. Are you sure? No crying afterwards? [y/n]: '
  then
    return $SUCCESS
  else
    echo
    err 'Seriously? No formatting no fun! Please format to continue or CTRL + c to cancel...'
    ask_formatting
  fi
}


# create LUKS encrypted partition
make_luks_partition()
{
  part="$1"

  title 'Hard Drive Setup > Partition Creation (crypto)'

  wprintf '[+] Creating LUKS partition'
  printf "\n\n"

  cryptsetup -q -y -v -i 100 luksFormat "$part" > $VERBOSE 2>&1 || { err 'Could not LUKS format, trying again.'; make_luks_partition "$@"; }
}


# open LUKS partition
open_luks_partition()
{
  part="$1"
  name="$2"

  title 'Hard Drive Setup > Partition Creation (crypto)'

  wprintf '[+] Opening LUKS partition'
  printf "\n\n"
  
  cryptsetup open "$part" "$name" > $VERBOSE 2>&1 || { err 'Could not open LUKS device, please try again and make sure that your password is correct.'; open_luks_partition "$@"; }
}


# create swap partition
make_swap_partition()
{
  title 'Hard Drive Setup > Partition Creation (swap)'

  wprintf '[+] Creating SWAP partition'
  printf "\n\n"
  
  mkswap $SWAP_PART > $VERBOSE 2>&1 || { err 'Could not create filesystem'; exit $FAILURE; }
}


# make and format root partition
make_root_partition()
{
  if [ $LUKS = $TRUE ]
  then
    make_luks_partition "$ROOT_PART"
    sleep_clear "$DELAY_1"
    open_luks_partition "$ROOT_PART" "$CRYPT_ROOT"
    sleep_clear "$DELAY_1"
    title 'Hard Drive Setup > Partition Creation (root crypto)'
    wprintf '[+] Creating encrypted ROOT partition'
    printf "\n\n"
    if [ "$ROOT_FS_TYPE" = 'btrfs' ]
    then
      mkfs.$ROOT_FS_TYPE -f "/dev/mapper/$CRYPT_ROOT" > $VERBOSE 2>&1 || { err 'Could not create filesystem'; exit $FAILURE; }
     else
      mkfs.$ROOT_FS_TYPE -F "/dev/mapper/$CRYPT_ROOT" > $VERBOSE 2>&1 || { err 'Could not create filesystem'; exit $FAILURE; }
      fi
    sleep_clear "$DELAY_1"
  else
    title 'Hard Drive Setup > Partition Creation (root)'
    wprintf '[+] Creating ROOT partition'
    printf "\n\n"
    if [ "$ROOT_FS_TYPE" = 'btrfs' ]
    then
      mkfs.$ROOT_FS_TYPE -f "$ROOT_PART" > $VERBOSE 2>&1 || { err 'Could not create filesystem'; exit $FAILURE; }
      else
      mkfs.$ROOT_FS_TYPE -F "$ROOT_PART" > $VERBOSE 2>&1 || { err 'Could not create filesystem'; exit $FAILURE; }
    fi
    sleep_clear "$DELAY_1"
  fi

sleep "$DELAY_10"

  return $SUCCESS
}


# make and format boot partition
make_boot_partition()
{
  title 'Hard Drive Setup > Partition Creation (boot)'

  wprintf '[+] Creating BOOT partition'
  printf "\n\n"
  if [ "$BOOT_MODE" = 'uefi' ] && [ "$PART_LABEL" = 'gpt' ]
  then
    mkfs.fat -F32 "$BOOT_PART" > $VERBOSE 2>&1 ||
      { err 'Could not create filesystem'; exit $FAILURE; }
  else
    mkfs.$BOOT_FS_TYPE -F "$BOOT_PART" > $VERBOSE 2>&1 ||
      { err 'Could not create filesystem'; exit $FAILURE; }
  fi

sleep "$DELAY_10"

  return $SUCCESS
}


# make and format partitions
make_partitions()
{
  make_boot_partition
  sleep_clear "$DELAY_1"

  make_root_partition
  sleep_clear "$DELAY_1"

  if [ "$SWAP_PART" != "none" ]
  then
    make_swap_partition
    sleep_clear "$DELAY_1"
  fi

  return $SUCCESS
}


# mount filesystems
mount_filesystems()
{
  title 'Hard Drive Setup > Mount'

  wprintf '[+] Mounting filesystems'
  printf "\n\n"

  # ROOT
  if [ $LUKS = $TRUE ]; then
    if ! mount "/dev/mapper/$CRYPT_ROOT" $CHROOT; then
      err "Error mounting root filesystem, leaving."
      exit $FAILURE
    fi
  else
    if ! mount "$ROOT_PART" $CHROOT; then
      err "Error mounting root filesystem, leaving."
      exit $FAILURE
    fi
  fi

  # BOOT
  mkdir "$CHROOT/boot" > $VERBOSE 2>&1
  if ! mount "$BOOT_PART" "$CHROOT/boot"; then
    err "Error mounting boot partition, leaving."
    exit $FAILURE
  fi

  # SWAP
  if [ "$SWAP_PART" != "none" ]
  then
    swapon $SWAP_PART > $VERBOSE 2>&1
  fi

  return $SUCCESS
}


# unmount filesystems
umount_filesystems()
{
  routine="$1"

  if [ "$routine" = 'harddrive' ]
  then
    title 'Hard Drive Setup > Unmount'

    wprintf '[+] Unmounting filesystems'
    printf "\n\n"

    umount -Rf /mnt > /dev/null 2>&1; \
    umount -Rf "$HD_DEV"{1..128} > /dev/null 2>&1 # gpt max - 128
  else
    title 'Game Over'

    wprintf '[+] Unmounting filesystems'
    printf "\n\n"

    umount -Rf $CHROOT > /dev/null 2>&1
    cryptsetup luksClose "$CRYPT_ROOT" > /dev/null 2>&1
    swapoff $SWAP_PART > /dev/null 2>&1
  fi

  return $SUCCESS
}


# check for necessary space
check_space()
{
  if [ $LUKS -eq $TRUE ]
  then
    avail_space=$(df -m | grep "/dev/mapper/$CRYPT_ROOT" | awk '{print $4}')
  else
    avail_space=$(df -m | grep "$ROOT_PART" | awk '{print $4}')
  fi

  if [ "$avail_space" -le 40960 ]
  then
    warn 'Arch Linux requires at least 40 GB of free space to install !'
  fi

  return $SUCCESS


}


# install ArchLinux base and base-devel packages
install_base_packages()
{
  title 'Base System Setup > ArchLinux Packages'

  wprintf '[+] Installing ArchLinux base packages'
  printf "\n\n"
  warn 'This can take a while, please wait...'
  printf "\n"

  pacstrap $CHROOT base base-devel btrfs-progs linux linux-firmware linux-headers terminus-font > $VERBOSE 2>&1
  chroot $CHROOT pacman -Syy --noconfirm --overwrite='*' > $VERBOSE 2>&1

  sleep "$DELAY_1"

  return $SUCCESS
}


# setup /etc/resolv.conf
setup_resolvconf()
{
  title 'Base System Setup > Etc'

  wprintf '[+] Setting up /etc/resolv.conf'
  printf "\n\n"

  mkdir -p "$CHROOT/etc/" > $VERBOSE 2>&1
  cp -L /etc/resolv.conf "$CHROOT/etc/resolv.conf" > $VERBOSE 2>&1

  return $SUCCESS
}


# setup fstab
setup_fstab()
{
  title 'Base System Setup > Etc'

  wprintf '[+] Setting up /etc/fstab'
  printf "\n\n"

  if [ "$PART_LABEL" = "gpt" ]
  then
    genfstab -U $CHROOT >> "$CHROOT/etc/fstab"
  else
    genfstab -L $CHROOT >> "$CHROOT/etc/fstab"
  fi

  sed 's/relatime/noatime/g' -i "$CHROOT/etc/fstab"

  return $SUCCESS
}


# setup locale and keymap
setup_locale()
{
  title 'Base System Setup > Locale'

  wprintf "[+] Setting up $LOCALE locale"
  printf "\n\n"
  sed -i "s/^#en_US.UTF-8/en_US.UTF-8/" "$CHROOT/etc/locale.gen"
  sed -i "s/^#$LOCALE/$LOCALE/" "$CHROOT/etc/locale.gen"
  chroot $CHROOT locale-gen > $VERBOSE 2>&1
  echo "LANG=$LOCALE" > "$CHROOT/etc/locale.conf"
  echo "KEYMAP=$KEYMAP" > "$CHROOT/etc/vconsole.conf"

  return $SUCCESS
}


# setup timezone
setup_time()
{
  if confirm 'Base System Setup > Timezone' '[?] Default: UTC. Choose other timezone [y/n]: '
  then
    for t in $(timedatectl list-timezones)
    do
      echo "    > $t"
    done

    wprintf "\n[?] What is your (Zone/SubZone): "
    read -r timezone
    chroot $CHROOT ln -sf "/usr/share/zoneinfo/$timezone" /etc/localtime > $VERBOSE 2>&1

    if [ $? -eq 1 ]
    then
      warn 'Do you live on Mars? Setting default time zone...'
      sleep "$DELAY_1"
      default_time
    else
      wprintf "\n[+] Time zone setup correctly\n"
    fi
  else
    wprintf "\n[+] Setting up default time and timezone\n"
    sleep "$DELAY_1"
    default_time
  fi

  printf "\n"

  return $SUCCESS
}


# default time and timezone
default_time()
{
  echo
  warn 'Setting up default time and timezone: UTC'
  printf "\n\n"
  chroot $CHROOT ln -sf /usr/share/zoneinfo/UTC /etc/localtime > $VERBOSE 2>&1

  return $SUCCESS
}


# setup initramfs
setup_initramfs()
{
  title 'Base System Setup > InitramFS'

  wprintf '[+] Setting up InitramFS'
  printf "\n\n"

  cp -f "$BI_PATH/data/etc/mkinitcpio.conf" "$CHROOT/etc/mkinitcpio.conf"
  cp -fr "$BI_PATH/data/etc/mkinitcpio.d" "$CHROOT/etc/"

  # terminus font
  sed -i 's/keyboard fsck/keyboard fsck consolefont/g' "$CHROOT/etc/mkinitcpio.conf"
  echo 'FONT=ter-114n' >> "$CHROOT/etc/vconsole.conf"

  if [ $LUKS = $TRUE ]
  then
    sed -i 's/block filesystems/block keymap encrypt filesystems/g' "$CHROOT/etc/mkinitcpio.conf"
  fi

  warn 'This can take a while, please wait...'
  printf "\n"
  chroot $CHROOT mkinitcpio -P > $VERBOSE 2>&1
  
  sleep "$DELAY_1"

  return $SUCCESS
}


# mount /proc, /sys and /dev
setup_proc_sys_dev()
{
  title 'Base System Setup > Proc Sys Dev'

  wprintf '[+] Setting up /proc, /sys and /dev'
  printf "\n\n"

  mkdir -p "${CHROOT}/"{proc,sys,dev} > $VERBOSE 2>&1

  mount -t proc proc "$CHROOT/proc" > $VERBOSE 2>&1
  mount --rbind /sys "$CHROOT/sys" > $VERBOSE 2>&1
  mount --make-rslave "$CHROOT/sys" > $VERBOSE 2>&1
  mount --rbind /dev "$CHROOT/dev" > $VERBOSE 2>&1
  mount --make-rslave "$CHROOT/dev" > $VERBOSE 2>&1

  return $SUCCESS
}


# setup hostname
setup_hostname()
{
  title 'Base System Setup > Hostname'

  wprintf '[+] Setting up hostname'
  printf "\n\n"

  echo "$HOST_NAME" > "$CHROOT/etc/hostname"

  return $SUCCESS
}


# setup boot loader for UEFI/GPT or BIOS/MBR
setup_bootloader()
{
  title 'Base System Setup > Boot Loader'

  if [ "$BOOT_MODE" = 'uefi' ] && [ "$PART_LABEL" = 'gpt' ]
  then
    wprintf '[+] Setting up EFI boot loader'
    printf "\n\n"

    chroot $CHROOT bootctl install > $VERBOSE 2>&1
    uuid="$(blkid "$ROOT_PART" | cut -d ' ' -f 2 | cut -d '"' -f 2)"

    if [ $LUKS = $TRUE ]
    then
      cat >> "$CHROOT/boot/loader/entries/arch.conf" << EOF
title   Arch Linux
linux   /vmlinuz-linux
initrd    /initramfs-linux.img
options   cryptdevice=UUID=$uuid:$CRYPT_ROOT root=/dev/mapper/$CRYPT_ROOT rw
EOF
    else
      cat >> "$CHROOT/boot/loader/entries/arch.conf" << EOF
title   Arch Linux
linux   /vmlinuz-linux
initrd    /initramfs-linux.img
options   root=UUID=$uuid rw
EOF
    fi
  else
    wprintf '[+] Setting up GRUB boot loader'
    printf "\n\n"

    uuid="$(lsblk -o UUID "$ROOT_PART" | sed -n 2p)"
    chroot $CHROOT pacman -S grub --noconfirm --overwrite='*' --needed > $VERBOSE 2>&1

    if [ $LUKS = $TRUE ]
    then
      sed -i "s|quiet|cryptdevice=UUID=$uuid:$CRYPT_ROOT root=/dev/mapper/$CRYPT_ROOT quiet|" \
        "$CHROOT/etc/default/grub"
    fi

    sed -i 's/#GRUB_COLOR_/GRUB_COLOR_/g' "$CHROOT/etc/default/grub"
    chroot $CHROOT grub-install --target=i386-pc "$HD_DEV" > $VERBOSE 2>&1
    chroot $CHROOT grub-mkconfig -o /boot/grub/grub.cfg > $VERBOSE 2>&1
  fi

  sleep "$DELAY_1"

  return $SUCCESS
}


# ask for normal user account to setup
ask_user_account()
{
  if confirm 'Base System Setup > User' '[?] Setup a normal user account [y/n]: '
  then
    wprintf '[?] User name: '
    read -r NORMAL_USER
  fi

  return $SUCCESS
}


# setup user account, password and environment
setup_user()
{
  user="$(echo "$1" | tr -dc '[:alnum:]_' | tr '[:upper:]' '[:lower:]' | cut -c 1-32)"

  title 'Base System Setup > User'

  wprintf "[+] Setting up $user account"
  printf "\n\n"

  # normal user
  if [ -n "$NORMAL_USER" ]
  then
    chroot $CHROOT groupadd "$user" > $VERBOSE 2>&1
    chroot $CHROOT useradd -g "$user" -d "/home/$user" -s "/bin/bash" -G "$user,wheel,users,video,audio" -m "$user" > $VERBOSE 2>&1
    chroot $CHROOT chown -R "$user":"$user" "/home/$user" > $VERBOSE 2>&1
    wprintf "[+] Added user: $user"
    printf "\n\n"
  fi

  # environment
  if [ -z "$NORMAL_USER" ]
  then
    cp -r "$BI_PATH/data/root/." "$CHROOT/root/." > $VERBOSE 2>&1
  else
    if [ "$INSTALL_MODE" != 'net' ]
    then
      cp -r "$BI_PATH/data/user/." "$CHROOT/home/$user/." > $VERBOSE 2>&1
      chroot $CHROOT chown -R "$user":"$user" "/home/$user" > $VERBOSE 2>&1
    else
      cp -r "$BI_PATH/data/root/." "$CHROOT/home/$user/." > $VERBOSE 2>&1
      chroot $CHROOT chown -R "$user":"$user" "/home/$user" > $VERBOSE 2>&1
    fi
  fi

  # password
  res=1337
  wprintf "[?] Set password for $user: "
  printf "\n\n"
  while [ $res -ne 0 ]
  do
    if [ "$user" = "root" ]
    then
      chroot $CHROOT passwd
    else
      chroot $CHROOT passwd "$user"
    fi
    res=$?
  done

  return $SUCCESS
}


# reinitialize arch keyring
reinitialize_keyring()
{
  title 'Base System Setup > Keyring Reinitialization'

  wprintf '[+] Reinitializing keyrings'
  printf "\n"

  chroot $CHROOT pacman -S --overwrite='*' --noconfirm archlinux-keyring > $VERBOSE 2>&1

  return $SUCCESS
}

# Installing YAY
install_yay()
{
  title 'Arch Linux Setup > YAY Install'
  wprintf '[+] Updating /usr/bin files'
  printf "\n\n"

  # /usr/bin/yay
  cp "$BI_PATH/data/usr/bin/yay" "$CHROOT/usr/bin/" > $VERBOSE 2>&1
  chmod +x "$CHROOT/usr/bin/yay"

  return $SUCCESS
}


# install extra (missing) packages
setup_extra_packages()
{
 
  dev='
  wireshark-qt
  tcpdump
  radare2
  metasploit
  code
  perl
  ruby
  nodejs
  yarn
  npm
  go'
  
  arch='
  aurpublish
  pacman-contrib'

  bluetooth='
  bluez
  bluez-tools 
  bluez-utils'

  browser='
  firefox'

  editor='
  leafpad
  hexedit 
  vim'

  filesystem='
  dosfstools 
  exfat-utils
  ntfs-3g'

  fonts='
  ttf-dejavu  
  xorg-fonts-misc'
  
  hardware='
  rfkill
  intel-ucode'

  kernel='
  bc
  linux-docs'

  misc='
  monero-gui
  gpa
  dmidecode
  ebtables
  polkit
  virt-manager
  arc-gtk-theme
  arc-icon-theme
  youtube-dl
  thunderbird
  lxappearance-gtk3
  nautilus
  go-ethereum
  telegram-desktop
  keepassxc
  tree
  libreoffice
  ranger
  neofetch
  evince
  tig
  mc
  acpi 
  alsa-utils
  bash-completion 
  cmake
  expac
  feh 
  git 
  haveged 
  hdparm
  htop 
  inotify-tools 
  ipython 
  irssi
  lsof 
  mesa 
  mlocate 
  moreutils 
  mpv 
  p7zip 
  rsync
  rtorrent 
  screen 
  scrot 
  smartmontools 
  strace 
  tmux 
  unrar
  unzip 
  upower 
  usb_modeswitch 
  usbutils 
  zip
  compton 
  nitrogen 
  pydf 
  sbxkb 
  lxrandr 
  newsboat 
  fish 
  sakura  
  python3 
  moc
  man
  man-pages
  qrencode'

  network='
  netsniff-ng
  iftop
  iptraf
  nethogs
  transmission-gtk
  wireguard-tools
  netctl
  net-tools
  gftp
  bind-tools 
  darkhttpd 
  dhclient 
  dhcpcd 
  dialog
  dnscrypt-proxy 
  dnsmasq 
  dnsutils 
  gnu-netcat 
  iw
  iwd 
  nfs-utils 
  ntp 
  openconnect 
  openssh 
  openvpn 
  socat 
  wget 
  wireless_tools 
  wpa_supplicant
  inetutils'
 
  xorg='
  xorg-setxkbmap
  xorg-server 
  xorg-xinit
  xterm'

  server='
  go
  mc 
  vim 
  pydf 
  openssh 
  git
  tmux
  netctl
  gnu-netcat 
  dhcpcd 
  dhclient 
  man
  man-pages
  tig
  htop
  tor 
  dnsutils 
  dialog
  make
  cmake
  net-tools 
  wget 
  inetutils 
  dmidecode 
  nmap'

  if [ "$INSTALL_MODE" != "gui" ]
  then
      ALL="$server"
  else
      ALL="$arch $bluetooth $browser $editor $filesystem $hardware $kernel $fonts $misc $network $xorg $dev"
  fi

  title 'Base System Setup > Extra Packages'

  wprintf '[+] Installing extra packages'
  printf "\n"
  
  if [ "$INSTALL_MODE" != "gui" ]
  then
  printf "
  > Server      : $(echo "$server" | wc -w) packages
  \n"

  else printf "
  > ArchLinux   : $(echo "$arch" | wc -w) packages
  > Browser     : $(echo "$browser" | wc -w) packages
  > Bluetooth   : $(echo "$bluetooth" | wc -w) packages
  > Editor      : $(echo "$editor" | wc -w) packages
  > Filesystem  : $(echo "$filesystem" | wc -w) packages
  > Fonts       : $(echo "$fonts" | wc -w) packages
  > Hardware    : $(echo "$hardware" | wc -w) packages
  > Kernel      : $(echo "$kernel" | wc -w) packages
  > Misc        : $(echo "$misc" | wc -w) packages
  > Network     : $(echo "$network" | wc -w) packages
  > Xorg        : $(echo "$xorg" | wc -w) packages
  \n"
  fi

  warn 'This can take a while, please wait...'
  printf "\n"

  chroot $CHROOT pacman -S --overwrite='*' --needed --noconfirm $ALL > $VERBOSE 2>&1
 
  sleep "$DELAY_1"

  return $SUCCESS
}


# perform system base setup/configurations
setup_base_system()
{

  pass_mirror_conf
  sleep_clear "$DELAY_1"

  setup_resolvconf
  sleep_clear "$DELAY_1"

  install_base_packages
  sleep_clear "$DELAY_1"

  setup_fstab
  sleep_clear "$DELAY_1"

  setup_proc_sys_dev
  sleep_clear "$DELAY_1"

  setup_locale
  sleep_clear "$DELAY_1"

  setup_initramfs
  sleep_clear "$DELAY_1"

  setup_hostname
  sleep_clear "$DELAY_1"

  setup_user "root"
  sleep_clear "$DELAY_1"

  ask_user_account
  sleep_clear "$DELAY_1"

  if [ -n "$NORMAL_USER" ]
  then
    setup_user "$NORMAL_USER"
    sleep_clear "$DELAY_1"
  fi

  reinitialize_keyring
  sleep_clear "$DELAY_1"

  setup_extra_packages
  sleep_clear "$DELAY_10"

  install_yay
  sleep_clear "$DELAY_1"

  setup_bootloader
  sleep_clear "$DELAY_10"

  return $SUCCESS
}


# enable systemd-networkd services
enable_iwd_networkd()
{
  title 'Arch Linux Setup > Network'

  wprintf '[+] Enabling IW_D / NETWORK_D & SSH_D & LIBVIRT_D'
  printf "\n\n"

  chroot $CHROOT systemctl enable iwd > $VERBOSE 2>&1
  chroot $CHROOT systemctl enable libvirtd > $VERBOSE 2>&1
  chroot $CHROOT systemctl enable systemd-networkd > $VERBOSE 2>&1
  chroot $CHROOT systemctl enable sshd systemd-networkd > $VERBOSE 2>&1

  return $SUCCESS
}


# update /etc files and set up iptables
update_etc()
{
  title 'Arch Linux Setup > Etc files'

  wprintf '[+] Updating /etc files'
  printf "\n\n"

  # /etc/*
  cp -rvf "$BI_PATH/data/etc/"{arch-release,motd,os-release,sysctl.d,systemd} "$CHROOT/etc/" > $VERBOSE 2>&1
  
  sleep "$DELAY_1"

  return $SUCCESS
}


# ask for archlinux server
ask_mirror_arch()
{
  local mirrold='cp /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.backup'

  if confirm 'Pacman Setup > ArchLinux Mirrorlist' \
    "[+] Worldwide mirror will be used\n\n[?] Look for the best server [y/n]: "
  then
    printf "\n"
    warn 'This may take time depending on your connection'
    printf "\n"
    $mirrold
    pacman -Sy --noconfirm > $VERBOSE 2>&1
    pacman -S --needed --noconfirm reflector > $VERBOSE 2>&1
    yes | pacman -Scc > $VERBOSE 2>&1
    reflector --verbose --protocol https --sort rate -l 3 --save /etc/pacman.d/mirrorlist > $VERBOSE 2>&1
  else
    printf "\n"
    warn 'Using Worldwide mirror server'
    $mirrold
    echo -e "## Arch Linux repository Worldwide mirrorlist\n\n" \
      > /etc/pacman.d/mirrorlist

    for wore in $ARCH_REPO_URL
    do
      echo "Server = $wore" >> /etc/pacman.d/mirrorlist
    done
  fi

}

# pass correct config
pass_mirror_conf()
{
  mkdir -p "$CHROOT/etc/pacman.d/" > $VERBOSE 2>&1
  cp -f /etc/pacman.d/mirrorlist "$CHROOT/etc/pacman.d/mirrorlist" > $VERBOSE 2>&1
}


# ask user for X (display + window manager) setup
ask_x_setup()
{
  if confirm 'Arch Linux Setup > X11' '[?] Setup X11 + Window Managers [y/n]: '
  then
    X_SETUP=$TRUE
  fi

  return $SUCCESS
}


# setup display manager
setup_display_manager(){
  title 'Arch Linux Setup > Display Manager'

  wprintf '[+] Setting up SLIM'
  printf "\n\n"

  # install slim package
  chroot $CHROOT pacman -S slim --needed --overwrite='*' --noconfirm > $VERBOSE 2>&1
  cp -rf "$BI_PATH/data/etc/X11/" "$CHROOT/etc/X11/" > $VERBOSE 2>&1
  chroot $CHROOT rm -rf /usr/share/slim/themes/default > $VERBOSE 2>&1
  cp -rf "$BI_PATH/data/usr/share/slim/themes/default/" "$CHROOT/usr/share/slim/themes/default/" > $VERBOSE 2>&1
  chroot $CHROOT systemctl enable slim > $VERBOSE 2>&1
  
  return $SUCCESS
}


# setup window managers
setup_window_managers()
{
  title 'Arch Linux Setup > Window Managers'

  wprintf '[+] Setting up i3'
  printf "\n\n"

  chroot $CHROOT pacman -Sy i3-gaps i3status i3lock rofi --needed --overwrite='*' --noconfirm > $VERBOSE 2>&1
  chroot $CHROOT mkdir -p /usr/share/wallpaper > $VERBOSE 2>&1
  cp -rf "$BI_PATH/data/usr/share/wallpaper/wall.jpg" "$CHROOT/usr/share/wallpaper/" > $VERBOSE 2>&1
  chroot $CHROOT rm /usr/share/xsessions/i3-with-shmlog.desktop > $VERBOSE 2>&1
  
  return $SUCCESS
}


# ask user for VMware modules + utils setup
ask_vmware_setup()
{
  if confirm 'Arch Linux Setup > VMware' '[?] Setup VMware modules [y/n]: '
  then
    VMWARE_SETUP=$TRUE
  fi

  return $SUCCESS
}


# setup vmware utils
setup_vmware_utils()
{
  title 'Arch Linux Setup > VMware'

  wprintf '[+] Setting up VMware utils'
  printf "\n\n"

  chroot $CHROOT pacman -Sy open-vm-tools xf86-video-vmware xf86-input-vmmouse --overwrite='*' --needed --noconfirm > $VERBOSE 2>&1
  chroot $CHROOT systemctl enable vmware-vmblock-fuse.service > $VERBOSE 2>&1
  chroot $CHROOT systemctl enable vmtoolsd.service > $VERBOSE 2>&1

  return $SUCCESS
}


# setup arch related stuff
setup_arch()
{
  update_etc
  sleep_clear "$DELAY_1"

  ask_x_setup
  sleep_clear "$DELAY_1"

  if [ $X_SETUP -eq $TRUE ]
  then
    setup_display_manager
    sleep_clear "$DELAY_1"
    setup_window_managers
    sleep_clear "$DELAY_1"
  fi

  enable_iwd_networkd
  sleep_clear "$DELAY_1"

  ask_vmware_setup
  sleep_clear "$DELAY_1"

  if [ $VMWARE_SETUP -eq $TRUE ]
  then
    setup_vmware_utils
    sleep_clear "$DELAY_1"
  fi

  enable_pacman_multilib 'chroot'
  sleep_clear "$DELAY_1"

  enable_pacman_color 'chroot'
  sleep_clear "$DELAY_1"
  
  enable_pacman_misc "chroot"
  sleep_clear "$DELAY_1"

  return $SUCCESS
}


# for fun and lulz
easter_backdoor()
{
  bar=0

  title 'Game Over'

  wprintf '[+] Arch Linux installation successfull!'
  printf "\n\n"

  wprintf 'Yo n00b, b4ckd00r1ng y0ur sy5t3m n0w '
  while [ $bar -ne 3 ]
  do
    wprintf "."
    sleep "$DELAY_1"
    bar=$((bar + 1))
  done
  
  printf "\n\n"

  return $SUCCESS
}


# perform sync
sync_disk()
{
  title 'Game Over'

  wprintf '[+] Syncing disk'
  printf "\n\n"

  sync

  return $SUCCESS
}


# check if new version available. perform self-update and exit
self_updater()
{
  title 'Self Updater'
  wprintf '[+] Checking for a new version of myself...'
  printf "\n\n"

  pacman -Syy > $VERBOSE 2>&1
  repo="$(pacman -Ss arch-installer | head -1 | cut -d ' ' -f 2 |
    cut -d '-' -f 1 | tr -d '.')0"
  this="$(echo $VERSION | tr -d '.')0"

  if [ "$this" -lt "$repo" ]
  then
    printf "\n\n"
    warn 'A new version is available! Going to fuck, err, update myself.'
    pacman -Sy --overwrite='*' --noconfirm arch-installer > $VERBOSE 2>&1
    yes | pacman -Scc > $VERBOSE 2>&1
    wprintf "\n[+] Updated successfully. Please restart the installer now!\n"
    chmod +x /usr/share/arch-installer/arch-install
    
    exit $SUCCESS
  fi

  return $SUCCESS
}


# controller and program flow
main()
{
  # do some ENV checks
  check_uid
  sleep_clear "$DELAY_1"
  check_env
  sleep_clear "$DELAY_1"
  check_boot_mode
  sleep_clear "$DELAY_1"

  # install & output mode
  ask_install_mode
  sleep_clear "$DELAY_1"
  ask_output_mode
  sleep_clear "$DELAY_1"

  # locale
  ask_locale
  sleep_clear "$DELAY_1"
  set_locale
  sleep_clear "$DELAY_1"

  # keymap
  ask_keymap
  sleep_clear "$DELAY_1"
  set_keymap
  sleep_clear "$DELAY_1"

  # network
  ask_hostname
  sleep_clear "$DELAY_1"
  get_net_ifs
  sleep_clear "$DELAY_1"
  ask_net_conf_mode
  sleep_clear "$DELAY_1"
  
  if [ "$NET_CONF_MODE" != "$NET_CONF_SKIP" ]
    then
      ask_net_if
    fi
    case "$NET_CONF_MODE" in
      "$NET_CONF_AUTO")
        net_conf_auto
        ;;
      "$NET_CONF_WLAN")
        ask_wlan_data
        net_conf_wlan
        ;;
      "$NET_CONF_MANUAL")
        ask_net_addr
        net_conf_manual
        ;;
      "$NET_CONF_SKIP")
        ;;
      *)
        ;;
    esac
  sleep_clear "$DELAY_1"
  check_inet_conn
  sleep_clear "$DELAY_1"

  # self_updater
  # sleep_clear "$DELAY_10"

  # pacman
  ask_mirror_arch
  sleep_clear "$DELAY_1"
  update_pacman
  sleep_clear "$DELAY_1"

  # hard drive
  get_hd_devs
  sleep_clear "$DELAY_1"
  ask_hd_dev
  sleep_clear "$DELAY_1"
  umount_filesystems 'harddrive'
  sleep_clear "$DELAY_1"
  ask_cfdisk
  sleep_clear "$DELAY_1"
  ask_luks
  sleep_clear "$DELAY_1"
  get_partition_label
  sleep_clear "$DELAY_1"
  ask_partitions
  sleep_clear "$DELAY_1"
  print_partitions
  sleep_clear "$DELAY_1"
  ask_formatting
  sleep_clear "$DELAY_1"
  make_partitions
  sleep_clear "$DELAY_1"
  mount_filesystems
  sleep_clear "$DELAY_1"

  # arch linux
  setup_base_system
  sleep_clear "$DELAY_1"
  setup_time
  sleep_clear "$DELAY_1"

  # arch setup
  setup_arch
  sleep_clear "$DELAY_1"

  # epilog
  umount_filesystems
  sleep_clear "$DELAY_1"
  sync_disk
  sleep_clear "$DELAY_1"
  easter_backdoor

  return $SUCCESS
}


# we start here
main "$@"
